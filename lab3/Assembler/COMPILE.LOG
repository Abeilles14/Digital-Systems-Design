KCPSM3  v1.30.      Ken Chapman (Xilinx-UK) 2005

The assembler for KCPSM3 Programmable State Machine

PASS 1 - Reading input PSM file

; KCPSM3 Program - Practice Picoblaze on Spartan-3A Starter Kit.
;
;
;
;
; The 8 LEDs provide a simple 'heart beat' counter driven by interrupts generated at
; one second intervals.
;
;
;**************************************************************************************
; Port definitions
;**************************************************************************************
;
;
;
CONSTANT LED_port, 80            ;8 simple LEDs. Is an OUTPUT port.
CONSTANT LED_0_port, 40          ;LED 0
CONSTANT DATA_IN_PORT, 00    ;input data port. INPUT port
; CONSTANT SSEG_PORT0, 40        ;7seg
; CONSTANT SSEG_PORT1, 20
; CONSTANT SSEG_PORT2, 10
;**************************************************************************************
; Special Register usage
;**************************************************************************************
;
; No registers are given special names in this program.
;
;**************************************************************************************
; Scratch Pad Memory Locations
;**************************************************************************************
;
;
CONSTANT ISR_preserve_s0, 00        ;Preserve s0 contents during ISR
CONSTANT ISR_preserve_s1, 01        ;Preserve s1 contents during ISR
CONSTANT ISR_preserve_s2, 02        ;Preserve s2 contents during ISR
CONSTANT ISR_preserve_s3, 03        ;Preserve s3 contents during ISR
CONSTANT ISR_restore_s1, 04
CONSTANT ISR_restore_s2, 05
CONSTANT ISR_restore_s3, 06
;
CONSTANT LED_pattern, 04            ;remember state of LEDs (8-bit counter in this case)
;
;**************************************************************************************
; Useful data constants
;**************************************************************************************
;
;
; Constant to define a software delay of 1us. This must be adjusted to reflect the
; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
; calculation highly predictable. The '6' in the following equation even allows for
; 'CALL delay_1us' instruction in the initiating code.
;
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
;
; Example: For a 50MHz clock the constant value is (50-6)/4 = 11  (0B Hex).
; For clock rates below 10MHz the value of 1 must be used and the operation will
; become lower than intended. Interrupts may effect the timing of software based
; delays.
;
CONSTANT delay_1us_constant, 0B
;
;
;
; ASCII table
;
CONSTANT character_a, 61
CONSTANT character_b, 62
CONSTANT character_c, 63
CONSTANT character_d, 64
CONSTANT character_e, 65
CONSTANT character_f, 66
CONSTANT character_g, 67
CONSTANT character_h, 68
CONSTANT character_i, 69
CONSTANT character_j, 6A
CONSTANT character_k, 6B
CONSTANT character_l, 6C
CONSTANT character_m, 6D
CONSTANT character_n, 6E
CONSTANT character_o, 6F
CONSTANT character_p, 70
CONSTANT character_q, 71
CONSTANT character_r, 72
CONSTANT character_s, 73
CONSTANT character_t, 74
CONSTANT character_u, 75
CONSTANT character_v, 76
CONSTANT character_w, 77
CONSTANT character_x, 78
CONSTANT character_y, 79
CONSTANT character_z, 7A
CONSTANT character_A, 41
CONSTANT character_B, 42
CONSTANT character_C, 43
CONSTANT character_D, 44
CONSTANT character_E, 45
CONSTANT character_F, 46
CONSTANT character_G, 47
CONSTANT character_H, 48
CONSTANT character_I, 49
CONSTANT character_J, 4A
CONSTANT character_K, 4B
CONSTANT character_L, 4C
CONSTANT character_M, 4D
CONSTANT character_N, 4E
CONSTANT character_O, 4F
CONSTANT character_P, 50
CONSTANT character_Q, 51
CONSTANT character_R, 52
CONSTANT character_S, 53
CONSTANT character_T, 54
CONSTANT character_U, 55
CONSTANT character_V, 56
CONSTANT character_W, 57
CONSTANT character_X, 58
CONSTANT character_Y, 59
CONSTANT character_Z, 5A
CONSTANT character_0, 30
CONSTANT character_1, 31
CONSTANT character_2, 32
CONSTANT character_3, 33
CONSTANT character_4, 34
CONSTANT character_5, 35
CONSTANT character_6, 36
CONSTANT character_7, 37
CONSTANT character_8, 38
CONSTANT character_9, 39
CONSTANT character_colon, 3A
CONSTANT character_stop, 2E
CONSTANT character_semi_colon, 3B
CONSTANT character_minus, 2D
CONSTANT character_divide, 2F       ;'/'
CONSTANT character_plus, 2B
CONSTANT character_comma, 2C
CONSTANT character_less_than, 3C
CONSTANT character_greater_than, 3E
CONSTANT character_equals, 3D
CONSTANT character_space, 20
CONSTANT character_CR, 0D           ;carriage return
CONSTANT character_question, 3F     ;'?'
CONSTANT character_dollar, 24
CONSTANT character_exclaim, 21      ;'!'
CONSTANT character_BS, 08           ;Back Space command character
;
;
;
;
;
;**************************************************************************************
; Initialise the system
;**************************************************************************************
;
cold_start:
LOAD s0, 00                         ;clear 1 second counter and clear LEDs
;LOAD s5, 00                        ;initialize LED direction left
STORE s0, LED_pattern
OUTPUT s0, LED_port
OUTPUT s0, LED_0_port
ENABLE INTERRUPT                    ;enable one second heart beat
;**************************************************************************************
; Main program
;**************************************************************************************
;
; Display welcome message for design
;
main_program:
LOAD s1, 01                   ;turn LED 0 on
OUTPUT s1, LED_0_port
CALL delay_1s
load s1, 00                   ;turn LED 0 off
OUTPUT s1, LED_0_port
CALL delay_1s;
JUMP main_program
;**************************************************************************************
; Routines to display hexadecimal values
;**************************************************************************************
;
;
; Convert hexadecimal value provided in register s0 into ASCII characters
;
; The value provided must can be any value in the range 00 to FF and will be converted into
; two ASCII characters.
;     The upper nibble will be represented by an ASCII character returned in register s3.
;     The lower nibble will be represented by an ASCII character returned in register s2.
;
; The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
; added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
; hexadecimal requiring a further addition of 07 to the 30 already added.
;
; Registers used s0, s2 and s3.
;
hex_byte_to_ASCII: LOAD s2, s0                         ;remember value supplied
SR0 s0                              ;isolate upper nibble
SR0 s0
SR0 s0
SR0 s0
CALL hex_to_ASCII                   ;convert
LOAD s3, s0                         ;upper nibble value in s3
LOAD s0, s2                         ;restore complete value
AND s0, 0F                          ;isolate lower nibble
CALL hex_to_ASCII                   ;convert
LOAD s2, s0                         ;lower nibble value in s2
RETURN
;
; Convert hexadecimal value provided in register s0 into ASCII character
;
;Register used s0
;
hex_to_ASCII: SUB s0, 0A                          ;test if value is in range 0 to 9
JUMP C, number_char
ADD s0, 07                          ;ASCII char A to F in range 41 to 46
number_char: ADD s0, 3A                          ;ASCII char 0 to 9 in range 30 to 40
RETURN
;**************************************************************************************
; Software delay routines
;**************************************************************************************
;
; Delay of 1us.
;
; Constant value 'delay_1us_constant' reflects the clock applied to KCPSM3. Every
; instruction executes in 2 clock cycles making the calculation highly predictable.
; The '6' in the following equation allows for the 'CALL delay_1us' instruction used
; in the initiating code. Interrupts may effect software derived delays.
;
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
;
; Registers used s0
;
delay_1us: LOAD s0, delay_1us_constant
wait_1us: SUB s0, 01
JUMP NZ, wait_1us
RETURN
;
; Delay of 40us.
;
; Registers used s0, s1
;
delay_40us: LOAD s1, 28                         ;40 x 1us = 40us
wait_40us: CALL delay_1us
SUB s1, 01
JUMP NZ, wait_40us
RETURN
;
;
; Delay of 1ms.
;
; Registers used s0, s1, s2
;
delay_1ms: LOAD s2, 19                         ;25 x 40us = 1ms
wait_1ms: CALL delay_40us
SUB s2, 01
JUMP NZ, wait_1ms
RETURN
;
; Delay of 20ms.
;
; Delay of 20ms used during initialisation.
;
; Registers used s0, s1, s2, s3
;
delay_20ms: LOAD s3, 14                         ;20 x 1ms = 20ms
wait_20ms: CALL delay_1ms
SUB s3, 01
JUMP NZ, wait_20ms
RETURN
delay_100ms: LOAD s3, 64                         ;100 x 1ms = 20ms
wait_100ms: CALL delay_1ms
SUB s3, 01
JUMP NZ, wait_100ms
RETURN
;
; Delay of approximately 1 second.
;
; Registers used s0, s1, s2, s3, s4
;
delay_1s: LOAD s4, 32                         ;50 x 20ms = 1000ms
wait_1s: CALL delay_20ms
SUB s4, 01
JUMP NZ, wait_1s
RETURN
;
;
;
;**************************************************************************************
; Interrupt Service Routine (ISR)
;**************************************************************************************
;
; The interrupt is used purely to provide a 1 second heart beat binary counter pattern
; on the 8 LEDs.
;
ISR:
STORE s0, ISR_preserve_s0
STORE s1, ISR_preserve_s1
STORE s2, ISR_preserve_s2
STORE s3, ISR_preserve_s3
FETCH s1, ISR_restore_s1           ;samples counter
FETCH s2, ISR_restore_s2           ;samples carry counter
FETCH s3, ISR_restore_s3           ;interrupts counter
INPUT s0, DATA_IN_PORT             ;get audio sample
COMPARE s0, 80                     ;check left bit for flash sample negative
JUMP C, add_sample                   ;if positive, jump to add to counter
absolute:      XOR s0, FF                         ;take complement
ADD s0, 01
add_sample:
ADD s1, s0
JUMP C, add_sample_carry                ;if carry from samples adding
inc_counter:   ADD s3, 01
JUMP C, LED_80                      ;if 256 values reached, divide samples by 256
return:
STORE s1, ISR_restore_s1
STORE s2, ISR_restore_s2
STORE s3, ISR_restore_s3
FETCH s0, ISR_preserve_s0
FETCH s1, ISR_preserve_s1
FETCH s2, ISR_preserve_s2
FETCH s3, ISR_preserve_s3
RETURNI ENABLE
add_sample_carry:
ADD s2, 01                      ;carry from add_sample
JUMP inc_counter
LED_80:
SL0 s2                          ;check for 1000_0000
JUMP NC, LED_40
LOAD s1, FF                     ;LED output 1111_1111
OUTPUT s1, LED_port
JUMP reset
LED_40:
SL0 s2                          ;check for 0100_0000
JUMP NC, LED_20
LOAD s1, FE                     ;LED output 1111_1110
OUTPUT s1, LED_port
JUMP reset
LED_20:
SL0 s2                          ;check for 0010_0000
JUMP NC, LED_10
LOAD s1, FC                     ;LED output 1111_1100
OUTPUT s1, LED_port
JUMP reset
LED_10:
SL0 s2                          ;check for 0001_0000
JUMP NC, LED_08
LOAD s1, F8                     ;LED output 1111_1000
OUTPUT s1, LED_port
JUMP reset
LED_08:
SL0 s2                          ;check for 0000_1000
JUMP NC, LED_04
LOAD s1, F0                     ;LED output 1111_0000
OUTPUT s1, LED_port
JUMP reset
LED_04:
SL0 s2                          ;check for 1000_0100
JUMP NC, LED_02
LOAD s1, E0                     ;LED output 1110_0000
OUTPUT s1, LED_port
JUMP reset
LED_02:
SL0 s2                          ;check for 0000_0010
JUMP NC, LED_01
LOAD s1, C0                     ;LED output 1100_0000
OUTPUT s1, LED_port
JUMP reset
LED_01:
SL0 s2                          ;check for 0000_0001
JUMP NC, LED_00
LOAD s1, 80                     ;LED output 1000_0000
OUTPUT s1, LED_port
LED_00:
LOAD s1, 00                     ;LED output 1000_0000
OUTPUT s1, LED_port
reset:
LOAD  s1, 00
LOAD  s2, 00
LOAD  s3, 00
JUMP return
;
;
;**************************************************************************************
; Interrupt Vector
;**************************************************************************************
;
ADDRESS 3FF
JUMP ISR
;
;

PASS 2 - Testing Instructions

; KCPSM3 Program - Practice Picoblaze on Spartan-3A Starter Kit.
;
;
;
;
; The 8 LEDs provide a simple 'heart beat' counter driven by interrupts generated at
; one second intervals.
;
;
;**************************************************************************************
; Port definitions
;**************************************************************************************
;
;
;
CONSTANT LED_port, 80;8 simple LEDs. Is an OUTPUT port.
CONSTANT LED_0_port, 40;LED 0
CONSTANT DATA_IN_PORT, 00;input data port. INPUT port
; CONSTANT SSEG_PORT0, 40        ;7seg
; CONSTANT SSEG_PORT1, 20
; CONSTANT SSEG_PORT2, 10
;**************************************************************************************
; Special Register usage
;**************************************************************************************
;
; No registers are given special names in this program.
;
;**************************************************************************************
; Scratch Pad Memory Locations
;**************************************************************************************
;
;
CONSTANT ISR_preserve_s0, 00;Preserve s0 contents during ISR
CONSTANT ISR_preserve_s1, 01;Preserve s1 contents during ISR
CONSTANT ISR_preserve_s2, 02;Preserve s2 contents during ISR
CONSTANT ISR_preserve_s3, 03;Preserve s3 contents during ISR
CONSTANT ISR_restore_s1, 04
CONSTANT ISR_restore_s2, 05
CONSTANT ISR_restore_s3, 06
;
CONSTANT LED_pattern, 04;remember state of LEDs (8-bit counter in this case)
;
;**************************************************************************************
; Useful data constants
;**************************************************************************************
;
;
; Constant to define a software delay of 1us. This must be adjusted to reflect the
; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
; calculation highly predictable. The '6' in the following equation even allows for
; 'CALL delay_1us' instruction in the initiating code.
;
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
;
; Example: For a 50MHz clock the constant value is (50-6)/4 = 11  (0B Hex).
; For clock rates below 10MHz the value of 1 must be used and the operation will
; become lower than intended. Interrupts may effect the timing of software based
; delays.
;
CONSTANT delay_1us_constant, 0B
;
;
;
; ASCII table
;
CONSTANT character_a, 61
CONSTANT character_b, 62
CONSTANT character_c, 63
CONSTANT character_d, 64
CONSTANT character_e, 65
CONSTANT character_f, 66
CONSTANT character_g, 67
CONSTANT character_h, 68
CONSTANT character_i, 69
CONSTANT character_j, 6A
CONSTANT character_k, 6B
CONSTANT character_l, 6C
CONSTANT character_m, 6D
CONSTANT character_n, 6E
CONSTANT character_o, 6F
CONSTANT character_p, 70
CONSTANT character_q, 71
CONSTANT character_r, 72
CONSTANT character_s, 73
CONSTANT character_t, 74
CONSTANT character_u, 75
CONSTANT character_v, 76
CONSTANT character_w, 77
CONSTANT character_x, 78
CONSTANT character_y, 79
CONSTANT character_z, 7A
CONSTANT character_A, 41
CONSTANT character_B, 42
CONSTANT character_C, 43
CONSTANT character_D, 44
CONSTANT character_E, 45
CONSTANT character_F, 46
CONSTANT character_G, 47
CONSTANT character_H, 48
CONSTANT character_I, 49
CONSTANT character_J, 4A
CONSTANT character_K, 4B
CONSTANT character_L, 4C
CONSTANT character_M, 4D
CONSTANT character_N, 4E
CONSTANT character_O, 4F
CONSTANT character_P, 50
CONSTANT character_Q, 51
CONSTANT character_R, 52
CONSTANT character_S, 53
CONSTANT character_T, 54
CONSTANT character_U, 55
CONSTANT character_V, 56
CONSTANT character_W, 57
CONSTANT character_X, 58
CONSTANT character_Y, 59
CONSTANT character_Z, 5A
CONSTANT character_0, 30
CONSTANT character_1, 31
CONSTANT character_2, 32
CONSTANT character_3, 33
CONSTANT character_4, 34
CONSTANT character_5, 35
CONSTANT character_6, 36
CONSTANT character_7, 37
CONSTANT character_8, 38
CONSTANT character_9, 39
CONSTANT character_colon, 3A
CONSTANT character_stop, 2E
CONSTANT character_semi_colon, 3B
CONSTANT character_minus, 2D
CONSTANT character_divide, 2F;'/'
CONSTANT character_plus, 2B
CONSTANT character_comma, 2C
CONSTANT character_less_than, 3C
CONSTANT character_greater_than, 3E
CONSTANT character_equals, 3D
CONSTANT character_space, 20
CONSTANT character_CR, 0D;carriage return
CONSTANT character_question, 3F;'?'
CONSTANT character_dollar, 24
CONSTANT character_exclaim, 21;'!'
CONSTANT character_BS, 08;Back Space command character
;
;
;
;
;
;**************************************************************************************
; Initialise the system
;**************************************************************************************
;
cold_start: 
LOAD s0, 00;clear 1 second counter and clear LEDs
;LOAD s5, 00                        ;initialize LED direction left
STORE s0, LED_pattern
OUTPUT s0, LED_port
OUTPUT s0, LED_0_port
ENABLE INTERRUPT;enable one second heart beat
;**************************************************************************************
; Main program
;**************************************************************************************
;
; Display welcome message for design
;
main_program: 
LOAD s1, 01;turn LED 0 on
OUTPUT s1, LED_0_port
CALL delay_1s
load s1, 00;turn LED 0 off
OUTPUT s1, LED_0_port
CALL delay_1s;
JUMP main_program
;**************************************************************************************
; Routines to display hexadecimal values
;**************************************************************************************
;
;
; Convert hexadecimal value provided in register s0 into ASCII characters
;
; The value provided must can be any value in the range 00 to FF and will be converted into
; two ASCII characters.
;     The upper nibble will be represented by an ASCII character returned in register s3.
;     The lower nibble will be represented by an ASCII character returned in register s2.
;
; The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
; added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
; hexadecimal requiring a further addition of 07 to the 30 already added.
;
; Registers used s0, s2 and s3.
;
hex_byte_to_ASCII: LOAD s2, s0;remember value supplied
SR0 s0;isolate upper nibble
SR0 s0
SR0 s0
SR0 s0
CALL hex_to_ASCII;convert
LOAD s3, s0;upper nibble value in s3
LOAD s0, s2;restore complete value
AND s0, 0F;isolate lower nibble
CALL hex_to_ASCII;convert
LOAD s2, s0;lower nibble value in s2
RETURN
;
; Convert hexadecimal value provided in register s0 into ASCII character
;
;Register used s0
;
hex_to_ASCII: SUB s0, 0A;test if value is in range 0 to 9
JUMP C, number_char
ADD s0, 07;ASCII char A to F in range 41 to 46
number_char: ADD s0, 3A;ASCII char 0 to 9 in range 30 to 40
RETURN
;**************************************************************************************
; Software delay routines
;**************************************************************************************
;
; Delay of 1us.
;
; Constant value 'delay_1us_constant' reflects the clock applied to KCPSM3. Every
; instruction executes in 2 clock cycles making the calculation highly predictable.
; The '6' in the following equation allows for the 'CALL delay_1us' instruction used
; in the initiating code. Interrupts may effect software derived delays.
;
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
;
; Registers used s0
;
delay_1us: LOAD s0, delay_1us_constant
wait_1us: SUB s0, 01
JUMP NZ, wait_1us
RETURN
;
; Delay of 40us.
;
; Registers used s0, s1
;
delay_40us: LOAD s1, 28;40 x 1us = 40us
wait_40us: CALL delay_1us
SUB s1, 01
JUMP NZ, wait_40us
RETURN
;
;
; Delay of 1ms.
;
; Registers used s0, s1, s2
;
delay_1ms: LOAD s2, 19;25 x 40us = 1ms
wait_1ms: CALL delay_40us
SUB s2, 01
JUMP NZ, wait_1ms
RETURN
;
; Delay of 20ms.
;
; Delay of 20ms used during initialisation.
;
; Registers used s0, s1, s2, s3
;
delay_20ms: LOAD s3, 14;20 x 1ms = 20ms
wait_20ms: CALL delay_1ms
SUB s3, 01
JUMP NZ, wait_20ms
RETURN
delay_100ms: LOAD s3, 64;100 x 1ms = 20ms
wait_100ms: CALL delay_1ms
SUB s3, 01
JUMP NZ, wait_100ms
RETURN
;
; Delay of approximately 1 second.
;
; Registers used s0, s1, s2, s3, s4
;
delay_1s: LOAD s4, 32;50 x 20ms = 1000ms
wait_1s: CALL delay_20ms
SUB s4, 01
JUMP NZ, wait_1s
RETURN
;
;
;
;**************************************************************************************
; Interrupt Service Routine (ISR)
;**************************************************************************************
;
; The interrupt is used purely to provide a 1 second heart beat binary counter pattern
; on the 8 LEDs.
;
ISR: 
STORE s0, ISR_preserve_s0
STORE s1, ISR_preserve_s1
STORE s2, ISR_preserve_s2
STORE s3, ISR_preserve_s3
FETCH s1, ISR_restore_s1;samples counter
FETCH s2, ISR_restore_s2;samples carry counter
FETCH s3, ISR_restore_s3;interrupts counter
INPUT s0, DATA_IN_PORT;get audio sample
COMPARE s0, 80;check left bit for flash sample negative
JUMP C, add_sample;if positive, jump to add to counter
absolute: XOR s0, FF;take complement
ADD s0, 01
add_sample: 
ADD s1, s0
JUMP C, add_sample_carry;if carry from samples adding
inc_counter: ADD s3, 01
JUMP C, LED_80;if 256 values reached, divide samples by 256
return: 
STORE s1, ISR_restore_s1
STORE s2, ISR_restore_s2
STORE s3, ISR_restore_s3
FETCH s0, ISR_preserve_s0
FETCH s1, ISR_preserve_s1
FETCH s2, ISR_preserve_s2
FETCH s3, ISR_preserve_s3
RETURNI ENABLE
add_sample_carry: 
ADD s2, 01;carry from add_sample
JUMP inc_counter
LED_80: 
SL0 s2;check for 1000_0000
JUMP NC, LED_40
LOAD s1, FF;LED output 1111_1111
OUTPUT s1, LED_port
JUMP reset
LED_40: 
SL0 s2;check for 0100_0000
JUMP NC, LED_20
LOAD s1, FE;LED output 1111_1110
OUTPUT s1, LED_port
JUMP reset
LED_20: 
SL0 s2;check for 0010_0000
JUMP NC, LED_10
LOAD s1, FC;LED output 1111_1100
OUTPUT s1, LED_port
JUMP reset
LED_10: 
SL0 s2;check for 0001_0000
JUMP NC, LED_08
LOAD s1, F8;LED output 1111_1000
OUTPUT s1, LED_port
JUMP reset
LED_08: 
SL0 s2;check for 0000_1000
JUMP NC, LED_04
LOAD s1, F0;LED output 1111_0000
OUTPUT s1, LED_port
JUMP reset
LED_04: 
SL0 s2;check for 1000_0100
JUMP NC, LED_02
LOAD s1, E0;LED output 1110_0000
OUTPUT s1, LED_port
JUMP reset
LED_02: 
SL0 s2;check for 0000_0010
JUMP NC, LED_01
LOAD s1, C0;LED output 1100_0000
OUTPUT s1, LED_port
JUMP reset
LED_01: 
SL0 s2;check for 0000_0001
JUMP NC, LED_00
LOAD s1, 80;LED output 1000_0000
OUTPUT s1, LED_port
LED_00: 
LOAD s1, 00;LED output 1000_0000
OUTPUT s1, LED_port
reset: 
LOAD s1, 00
LOAD s2, 00
LOAD s3, 00
JUMP return
;
;
;**************************************************************************************
; Interrupt Vector
;**************************************************************************************
;
ADDRESS 3FF
JUMP ISR
;
;

PASS 3 - Resolving addresses and line labels

000 ; KCPSM3 Program - Practice Picoblaze on Spartan-3A Starter Kit.
000 ;
000 ;
000 ;
000 ;
000 
; The 8 LEDs provide a simple 'heart beat' counter driven by interrupts generated at
000 ; one second intervals.
000 ;
000 ;
000 
;**************************************************************************************
000 ; Port definitions
000 
;**************************************************************************************
000 ;
000 ;
000 ;
000 CONSTANT LED_port, 80;8 simple LEDs. Is an OUTPUT port.
000 CONSTANT LED_0_port, 40;LED 0
000 CONSTANT DATA_IN_PORT, 00;input data port. INPUT port
000 ; CONSTANT SSEG_PORT0, 40        ;7seg
000 ; CONSTANT SSEG_PORT1, 20
000 ; CONSTANT SSEG_PORT2, 10
000 
;**************************************************************************************
000 ; Special Register usage
000 
;**************************************************************************************
000 ;
000 ; No registers are given special names in this program.
000 ;
000 
;**************************************************************************************
000 ; Scratch Pad Memory Locations
000 
;**************************************************************************************
000 ;
000 ;
000 CONSTANT ISR_preserve_s0, 00;Preserve s0 contents during ISR
000 CONSTANT ISR_preserve_s1, 01;Preserve s1 contents during ISR
000 CONSTANT ISR_preserve_s2, 02;Preserve s2 contents during ISR
000 CONSTANT ISR_preserve_s3, 03;Preserve s3 contents during ISR
000 CONSTANT ISR_restore_s1, 04
000 CONSTANT ISR_restore_s2, 05
000 CONSTANT ISR_restore_s3, 06
000 ;
000 CONSTANT LED_pattern, 04;remember state of LEDs (8-bit counter in this case)
000 ;
000 
;**************************************************************************************
000 ; Useful data constants
000 
;**************************************************************************************
000 ;
000 ;
000 
; Constant to define a software delay of 1us. This must be adjusted to reflect the
000 
; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
000 
; calculation highly predictable. The '6' in the following equation even allows for
000 ; 'CALL delay_1us' instruction in the initiating code.
000 ;
000 
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
000 ;
000 ; Example: For a 50MHz clock the constant value is (50-6)/4 = 11  (0B Hex).
000 
; For clock rates below 10MHz the value of 1 must be used and the operation will
000 
; become lower than intended. Interrupts may effect the timing of software based
000 ; delays.
000 ;
000 CONSTANT delay_1us_constant, 0B
000 ;
000 ;
000 ;
000 ; ASCII table
000 ;
000 CONSTANT character_a, 61
000 CONSTANT character_b, 62
000 CONSTANT character_c, 63
000 CONSTANT character_d, 64
000 CONSTANT character_e, 65
000 CONSTANT character_f, 66
000 CONSTANT character_g, 67
000 CONSTANT character_h, 68
000 CONSTANT character_i, 69
000 CONSTANT character_j, 6A
000 CONSTANT character_k, 6B
000 CONSTANT character_l, 6C
000 CONSTANT character_m, 6D
000 CONSTANT character_n, 6E
000 CONSTANT character_o, 6F
000 CONSTANT character_p, 70
000 CONSTANT character_q, 71
000 CONSTANT character_r, 72
000 CONSTANT character_s, 73
000 CONSTANT character_t, 74
000 CONSTANT character_u, 75
000 CONSTANT character_v, 76
000 CONSTANT character_w, 77
000 CONSTANT character_x, 78
000 CONSTANT character_y, 79
000 CONSTANT character_z, 7A
000 CONSTANT character_A, 41
000 CONSTANT character_B, 42
000 CONSTANT character_C, 43
000 CONSTANT character_D, 44
000 CONSTANT character_E, 45
000 CONSTANT character_F, 46
000 CONSTANT character_G, 47
000 CONSTANT character_H, 48
000 CONSTANT character_I, 49
000 CONSTANT character_J, 4A
000 CONSTANT character_K, 4B
000 CONSTANT character_L, 4C
000 CONSTANT character_M, 4D
000 CONSTANT character_N, 4E
000 CONSTANT character_O, 4F
000 CONSTANT character_P, 50
000 CONSTANT character_Q, 51
000 CONSTANT character_R, 52
000 CONSTANT character_S, 53
000 CONSTANT character_T, 54
000 CONSTANT character_U, 55
000 CONSTANT character_V, 56
000 CONSTANT character_W, 57
000 CONSTANT character_X, 58
000 CONSTANT character_Y, 59
000 CONSTANT character_Z, 5A
000 CONSTANT character_0, 30
000 CONSTANT character_1, 31
000 CONSTANT character_2, 32
000 CONSTANT character_3, 33
000 CONSTANT character_4, 34
000 CONSTANT character_5, 35
000 CONSTANT character_6, 36
000 CONSTANT character_7, 37
000 CONSTANT character_8, 38
000 CONSTANT character_9, 39
000 CONSTANT character_colon, 3A
000 CONSTANT character_stop, 2E
000 CONSTANT character_semi_colon, 3B
000 CONSTANT character_minus, 2D
000 CONSTANT character_divide, 2F;'/'
000 CONSTANT character_plus, 2B
000 CONSTANT character_comma, 2C
000 CONSTANT character_less_than, 3C
000 CONSTANT character_greater_than, 3E
000 CONSTANT character_equals, 3D
000 CONSTANT character_space, 20
000 CONSTANT character_CR, 0D;carriage return
000 CONSTANT character_question, 3F;'?'
000 CONSTANT character_dollar, 24
000 CONSTANT character_exclaim, 21;'!'
000 CONSTANT character_BS, 08;Back Space command character
000 ;
000 ;
000 ;
000 ;
000 ;
000 
;**************************************************************************************
000 ; Initialise the system
000 
;**************************************************************************************
000 ;
000 cold_start: 
000 LOAD s0, 00;clear 1 second counter and clear LEDs
001 ;LOAD s5, 00                        ;initialize LED direction left
001 STORE s0, LED_pattern
002 OUTPUT s0, LED_port
003 OUTPUT s0, LED_0_port
004 ENABLE INTERRUPT;enable one second heart beat
005 
;**************************************************************************************
005 ; Main program
005 
;**************************************************************************************
005 ;
005 ; Display welcome message for design
005 ;
005 main_program: 
005 LOAD s1, 01;turn LED 0 on
006 OUTPUT s1, LED_0_port
007 CALL delay_1s
008 LOAD s1, 00;turn LED 0 off
009 OUTPUT s1, LED_0_port
00A CALL delay_1s;
00B JUMP main_program
00C 
;**************************************************************************************
00C ; Routines to display hexadecimal values
00C 
;**************************************************************************************
00C ;
00C ;
00C ; Convert hexadecimal value provided in register s0 into ASCII characters
00C ;
00C 
; The value provided must can be any value in the range 00 to FF and will be converted into
00C ; two ASCII characters.
00C 
;     The upper nibble will be represented by an ASCII character returned in register s3.
00C 
;     The lower nibble will be represented by an ASCII character returned in register s2.
00C ;
00C 
; The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
00C 
; added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
00C ; hexadecimal requiring a further addition of 07 to the 30 already added.
00C ;
00C ; Registers used s0, s2 and s3.
00C ;
00C hex_byte_to_ASCII: LOAD s2, s0;remember value supplied
00D SR0 s0;isolate upper nibble
00E SR0 s0
00F SR0 s0
010 SR0 s0
011 CALL hex_to_ASCII;convert
012 LOAD s3, s0;upper nibble value in s3
013 LOAD s0, s2;restore complete value
014 AND s0, 0F;isolate lower nibble
015 CALL hex_to_ASCII;convert
016 LOAD s2, s0;lower nibble value in s2
017 RETURN
018 ;
018 ; Convert hexadecimal value provided in register s0 into ASCII character
018 ;
018 ;Register used s0
018 ;
018 hex_to_ASCII: SUB s0, 0A;test if value is in range 0 to 9
019 JUMP C, number_char
01A ADD s0, 07;ASCII char A to F in range 41 to 46
01B number_char: ADD s0, 3A;ASCII char 0 to 9 in range 30 to 40
01C RETURN
01D 
;**************************************************************************************
01D ; Software delay routines
01D 
;**************************************************************************************
01D ;
01D ; Delay of 1us.
01D ;
01D 
; Constant value 'delay_1us_constant' reflects the clock applied to KCPSM3. Every
01D 
; instruction executes in 2 clock cycles making the calculation highly predictable.
01D 
; The '6' in the following equation allows for the 'CALL delay_1us' instruction used
01D ; in the initiating code. Interrupts may effect software derived delays.
01D ;
01D 
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
01D ;
01D ; Registers used s0
01D ;
01D delay_1us: LOAD s0, delay_1us_constant
01E wait_1us: SUB s0, 01
01F JUMP NZ, wait_1us
020 RETURN
021 ;
021 ; Delay of 40us.
021 ;
021 ; Registers used s0, s1
021 ;
021 delay_40us: LOAD s1, 28;40 x 1us = 40us
022 wait_40us: CALL delay_1us
023 SUB s1, 01
024 JUMP NZ, wait_40us
025 RETURN
026 ;
026 ;
026 ; Delay of 1ms.
026 ;
026 ; Registers used s0, s1, s2
026 ;
026 delay_1ms: LOAD s2, 19;25 x 40us = 1ms
027 wait_1ms: CALL delay_40us
028 SUB s2, 01
029 JUMP NZ, wait_1ms
02A RETURN
02B ;
02B ; Delay of 20ms.
02B ;
02B ; Delay of 20ms used during initialisation.
02B ;
02B ; Registers used s0, s1, s2, s3
02B ;
02B delay_20ms: LOAD s3, 14;20 x 1ms = 20ms
02C wait_20ms: CALL delay_1ms
02D SUB s3, 01
02E JUMP NZ, wait_20ms
02F RETURN
030 delay_100ms: LOAD s3, 64;100 x 1ms = 20ms
031 wait_100ms: CALL delay_1ms
032 SUB s3, 01
033 JUMP NZ, wait_100ms
034 RETURN
035 ;
035 ; Delay of approximately 1 second.
035 ;
035 ; Registers used s0, s1, s2, s3, s4
035 ;
035 delay_1s: LOAD s4, 32;50 x 20ms = 1000ms
036 wait_1s: CALL delay_20ms
037 SUB s4, 01
038 JUMP NZ, wait_1s
039 RETURN
03A ;
03A ;
03A ;
03A 
;**************************************************************************************
03A ; Interrupt Service Routine (ISR)
03A 
;**************************************************************************************
03A ;
03A 
; The interrupt is used purely to provide a 1 second heart beat binary counter pattern
03A ; on the 8 LEDs.
03A ;
03A ISR: 
03A STORE s0, ISR_preserve_s0
03B STORE s1, ISR_preserve_s1
03C STORE s2, ISR_preserve_s2
03D STORE s3, ISR_preserve_s3
03E FETCH s1, ISR_restore_s1;samples counter
03F FETCH s2, ISR_restore_s2;samples carry counter
040 FETCH s3, ISR_restore_s3;interrupts counter
041 INPUT s0, DATA_IN_PORT;get audio sample
042 COMPARE s0, 80;check left bit for flash sample negative
043 JUMP C, add_sample;if positive, jump to add to counter
044 absolute: XOR s0, FF;take complement
045 ADD s0, 01
046 add_sample: 
046 ADD s1, s0
047 JUMP C, add_sample_carry;if carry from samples adding
048 inc_counter: ADD s3, 01
049 JUMP C, LED_80;if 256 values reached, divide samples by 256
04A return: 
04A STORE s1, ISR_restore_s1
04B STORE s2, ISR_restore_s2
04C STORE s3, ISR_restore_s3
04D FETCH s0, ISR_preserve_s0
04E FETCH s1, ISR_preserve_s1
04F FETCH s2, ISR_preserve_s2
050 FETCH s3, ISR_preserve_s3
051 RETURNI ENABLE
052 add_sample_carry: 
052 ADD s2, 01;carry from add_sample
053 JUMP inc_counter
054 LED_80: 
054 SL0 s2;check for 1000_0000
055 JUMP NC, LED_40
056 LOAD s1, FF;LED output 1111_1111
057 OUTPUT s1, LED_port
058 JUMP reset
059 LED_40: 
059 SL0 s2;check for 0100_0000
05A JUMP NC, LED_20
05B LOAD s1, FE;LED output 1111_1110
05C OUTPUT s1, LED_port
05D JUMP reset
05E LED_20: 
05E SL0 s2;check for 0010_0000
05F JUMP NC, LED_10
060 LOAD s1, FC;LED output 1111_1100
061 OUTPUT s1, LED_port
062 JUMP reset
063 LED_10: 
063 SL0 s2;check for 0001_0000
064 JUMP NC, LED_08
065 LOAD s1, F8;LED output 1111_1000
066 OUTPUT s1, LED_port
067 JUMP reset
068 LED_08: 
068 SL0 s2;check for 0000_1000
069 JUMP NC, LED_04
06A LOAD s1, F0;LED output 1111_0000
06B OUTPUT s1, LED_port
06C JUMP reset
06D LED_04: 
06D SL0 s2;check for 1000_0100
06E JUMP NC, LED_02
06F LOAD s1, E0;LED output 1110_0000
070 OUTPUT s1, LED_port
071 JUMP reset
072 LED_02: 
072 SL0 s2;check for 0000_0010
073 JUMP NC, LED_01
074 LOAD s1, C0;LED output 1100_0000
075 OUTPUT s1, LED_port
076 JUMP reset
077 LED_01: 
077 SL0 s2;check for 0000_0001
078 JUMP NC, LED_00
079 LOAD s1, 80;LED output 1000_0000
07A OUTPUT s1, LED_port
07B LED_00: 
07B LOAD s1, 00;LED output 1000_0000
07C OUTPUT s1, LED_port
07D reset: 
07D LOAD s1, 00
07E LOAD s2, 00
07F LOAD s3, 00
080 JUMP return
081 ;
081 ;
081 
;**************************************************************************************
081 ; Interrupt Vector
081 
;**************************************************************************************
081 ;
081 ADDRESS 3FF
3FF JUMP ISR
3FF ;
3FF ;

PASS 4 - Resolving Operands

000 ; KCPSM3 Program - Practice Picoblaze on Spartan-3A Starter Kit.
000 ;
000 ;
000 ;
000 ;
000 
; The 8 LEDs provide a simple 'heart beat' counter driven by interrupts generated at
000 ; one second intervals.
000 ;
000 ;
000 
;**************************************************************************************
000 ; Port definitions
000 
;**************************************************************************************
000 ;
000 ;
000 ;
000 CONSTANT LED_port, 80;8 simple LEDs. Is an OUTPUT port.
000 CONSTANT LED_0_port, 40;LED 0
000 CONSTANT DATA_IN_PORT, 00;input data port. INPUT port
000 ; CONSTANT SSEG_PORT0, 40        ;7seg
000 ; CONSTANT SSEG_PORT1, 20
000 ; CONSTANT SSEG_PORT2, 10
000 
;**************************************************************************************
000 ; Special Register usage
000 
;**************************************************************************************
000 ;
000 ; No registers are given special names in this program.
000 ;
000 
;**************************************************************************************
000 ; Scratch Pad Memory Locations
000 
;**************************************************************************************
000 ;
000 ;
000 CONSTANT ISR_preserve_s0, 00;Preserve s0 contents during ISR
000 CONSTANT ISR_preserve_s1, 01;Preserve s1 contents during ISR
000 CONSTANT ISR_preserve_s2, 02;Preserve s2 contents during ISR
000 CONSTANT ISR_preserve_s3, 03;Preserve s3 contents during ISR
000 CONSTANT ISR_restore_s1, 04
000 CONSTANT ISR_restore_s2, 05
000 CONSTANT ISR_restore_s3, 06
000 ;
000 CONSTANT LED_pattern, 04;remember state of LEDs (8-bit counter in this case)
000 ;
000 
;**************************************************************************************
000 ; Useful data constants
000 
;**************************************************************************************
000 ;
000 ;
000 
; Constant to define a software delay of 1us. This must be adjusted to reflect the
000 
; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
000 
; calculation highly predictable. The '6' in the following equation even allows for
000 ; 'CALL delay_1us' instruction in the initiating code.
000 ;
000 
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
000 ;
000 ; Example: For a 50MHz clock the constant value is (50-6)/4 = 11  (0B Hex).
000 
; For clock rates below 10MHz the value of 1 must be used and the operation will
000 
; become lower than intended. Interrupts may effect the timing of software based
000 ; delays.
000 ;
000 CONSTANT delay_1us_constant, 0B
000 ;
000 ;
000 ;
000 ; ASCII table
000 ;
000 CONSTANT character_a, 61
000 CONSTANT character_b, 62
000 CONSTANT character_c, 63
000 CONSTANT character_d, 64
000 CONSTANT character_e, 65
000 CONSTANT character_f, 66
000 CONSTANT character_g, 67
000 CONSTANT character_h, 68
000 CONSTANT character_i, 69
000 CONSTANT character_j, 6A
000 CONSTANT character_k, 6B
000 CONSTANT character_l, 6C
000 CONSTANT character_m, 6D
000 CONSTANT character_n, 6E
000 CONSTANT character_o, 6F
000 CONSTANT character_p, 70
000 CONSTANT character_q, 71
000 CONSTANT character_r, 72
000 CONSTANT character_s, 73
000 CONSTANT character_t, 74
000 CONSTANT character_u, 75
000 CONSTANT character_v, 76
000 CONSTANT character_w, 77
000 CONSTANT character_x, 78
000 CONSTANT character_y, 79
000 CONSTANT character_z, 7A
000 CONSTANT character_A, 41
000 CONSTANT character_B, 42
000 CONSTANT character_C, 43
000 CONSTANT character_D, 44
000 CONSTANT character_E, 45
000 CONSTANT character_F, 46
000 CONSTANT character_G, 47
000 CONSTANT character_H, 48
000 CONSTANT character_I, 49
000 CONSTANT character_J, 4A
000 CONSTANT character_K, 4B
000 CONSTANT character_L, 4C
000 CONSTANT character_M, 4D
000 CONSTANT character_N, 4E
000 CONSTANT character_O, 4F
000 CONSTANT character_P, 50
000 CONSTANT character_Q, 51
000 CONSTANT character_R, 52
000 CONSTANT character_S, 53
000 CONSTANT character_T, 54
000 CONSTANT character_U, 55
000 CONSTANT character_V, 56
000 CONSTANT character_W, 57
000 CONSTANT character_X, 58
000 CONSTANT character_Y, 59
000 CONSTANT character_Z, 5A
000 CONSTANT character_0, 30
000 CONSTANT character_1, 31
000 CONSTANT character_2, 32
000 CONSTANT character_3, 33
000 CONSTANT character_4, 34
000 CONSTANT character_5, 35
000 CONSTANT character_6, 36
000 CONSTANT character_7, 37
000 CONSTANT character_8, 38
000 CONSTANT character_9, 39
000 CONSTANT character_colon, 3A
000 CONSTANT character_stop, 2E
000 CONSTANT character_semi_colon, 3B
000 CONSTANT character_minus, 2D
000 CONSTANT character_divide, 2F;'/'
000 CONSTANT character_plus, 2B
000 CONSTANT character_comma, 2C
000 CONSTANT character_less_than, 3C
000 CONSTANT character_greater_than, 3E
000 CONSTANT character_equals, 3D
000 CONSTANT character_space, 20
000 CONSTANT character_CR, 0D;carriage return
000 CONSTANT character_question, 3F;'?'
000 CONSTANT character_dollar, 24
000 CONSTANT character_exclaim, 21;'!'
000 CONSTANT character_BS, 08;Back Space command character
000 ;
000 ;
000 ;
000 ;
000 ;
000 
;**************************************************************************************
000 ; Initialise the system
000 
;**************************************************************************************
000 ;
000 cold_start: 
000 LOAD s0, 00;clear 1 second counter and clear LEDs
001 ;LOAD s5, 00                        ;initialize LED direction left
001 STORE s0, LED_pattern
002 OUTPUT s0, LED_port
003 OUTPUT s0, LED_0_port
004 ENABLE INTERRUPT;enable one second heart beat
005 
;**************************************************************************************
005 ; Main program
005 
;**************************************************************************************
005 ;
005 ; Display welcome message for design
005 ;
005 main_program: 
005 LOAD s1, 01;turn LED 0 on
006 OUTPUT s1, LED_0_port
007 CALL delay_1s
008 LOAD s1, 00;turn LED 0 off
009 OUTPUT s1, LED_0_port
00A CALL delay_1s;
00B JUMP main_program
00C 
;**************************************************************************************
00C ; Routines to display hexadecimal values
00C 
;**************************************************************************************
00C ;
00C ;
00C ; Convert hexadecimal value provided in register s0 into ASCII characters
00C ;
00C 
; The value provided must can be any value in the range 00 to FF and will be converted into
00C ; two ASCII characters.
00C 
;     The upper nibble will be represented by an ASCII character returned in register s3.
00C 
;     The lower nibble will be represented by an ASCII character returned in register s2.
00C ;
00C 
; The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
00C 
; added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
00C ; hexadecimal requiring a further addition of 07 to the 30 already added.
00C ;
00C ; Registers used s0, s2 and s3.
00C ;
00C hex_byte_to_ASCII: LOAD s2, s0;remember value supplied
00D SR0 s0;isolate upper nibble
00E SR0 s0
00F SR0 s0
010 SR0 s0
011 CALL hex_to_ASCII;convert
012 LOAD s3, s0;upper nibble value in s3
013 LOAD s0, s2;restore complete value
014 AND s0, 0F;isolate lower nibble
015 CALL hex_to_ASCII;convert
016 LOAD s2, s0;lower nibble value in s2
017 RETURN
018 ;
018 ; Convert hexadecimal value provided in register s0 into ASCII character
018 ;
018 ;Register used s0
018 ;
018 hex_to_ASCII: SUB s0, 0A;test if value is in range 0 to 9
019 JUMP C, number_char
01A ADD s0, 07;ASCII char A to F in range 41 to 46
01B number_char: ADD s0, 3A;ASCII char 0 to 9 in range 30 to 40
01C RETURN
01D 
;**************************************************************************************
01D ; Software delay routines
01D 
;**************************************************************************************
01D ;
01D ; Delay of 1us.
01D ;
01D 
; Constant value 'delay_1us_constant' reflects the clock applied to KCPSM3. Every
01D 
; instruction executes in 2 clock cycles making the calculation highly predictable.
01D 
; The '6' in the following equation allows for the 'CALL delay_1us' instruction used
01D ; in the initiating code. Interrupts may effect software derived delays.
01D ;
01D 
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
01D ;
01D ; Registers used s0
01D ;
01D delay_1us: LOAD s0, delay_1us_constant
01E wait_1us: SUB s0, 01
01F JUMP NZ, wait_1us
020 RETURN
021 ;
021 ; Delay of 40us.
021 ;
021 ; Registers used s0, s1
021 ;
021 delay_40us: LOAD s1, 28;40 x 1us = 40us
022 wait_40us: CALL delay_1us
023 SUB s1, 01
024 JUMP NZ, wait_40us
025 RETURN
026 ;
026 ;
026 ; Delay of 1ms.
026 ;
026 ; Registers used s0, s1, s2
026 ;
026 delay_1ms: LOAD s2, 19;25 x 40us = 1ms
027 wait_1ms: CALL delay_40us
028 SUB s2, 01
029 JUMP NZ, wait_1ms
02A RETURN
02B ;
02B ; Delay of 20ms.
02B ;
02B ; Delay of 20ms used during initialisation.
02B ;
02B ; Registers used s0, s1, s2, s3
02B ;
02B delay_20ms: LOAD s3, 14;20 x 1ms = 20ms
02C wait_20ms: CALL delay_1ms
02D SUB s3, 01
02E JUMP NZ, wait_20ms
02F RETURN
030 delay_100ms: LOAD s3, 64;100 x 1ms = 20ms
031 wait_100ms: CALL delay_1ms
032 SUB s3, 01
033 JUMP NZ, wait_100ms
034 RETURN
035 ;
035 ; Delay of approximately 1 second.
035 ;
035 ; Registers used s0, s1, s2, s3, s4
035 ;
035 delay_1s: LOAD s4, 32;50 x 20ms = 1000ms
036 wait_1s: CALL delay_20ms
037 SUB s4, 01
038 JUMP NZ, wait_1s
039 RETURN
03A ;
03A ;
03A ;
03A 
;**************************************************************************************
03A ; Interrupt Service Routine (ISR)
03A 
;**************************************************************************************
03A ;
03A 
; The interrupt is used purely to provide a 1 second heart beat binary counter pattern
03A ; on the 8 LEDs.
03A ;
03A ISR: 
03A STORE s0, ISR_preserve_s0
03B STORE s1, ISR_preserve_s1
03C STORE s2, ISR_preserve_s2
03D STORE s3, ISR_preserve_s3
03E FETCH s1, ISR_restore_s1;samples counter
03F FETCH s2, ISR_restore_s2;samples carry counter
040 FETCH s3, ISR_restore_s3;interrupts counter
041 INPUT s0, DATA_IN_PORT;get audio sample
042 COMPARE s0, 80;check left bit for flash sample negative
043 JUMP C, add_sample;if positive, jump to add to counter
044 absolute: XOR s0, FF;take complement
045 ADD s0, 01
046 add_sample: 
046 ADD s1, s0
047 JUMP C, add_sample_carry;if carry from samples adding
048 inc_counter: ADD s3, 01
049 JUMP C, LED_80;if 256 values reached, divide samples by 256
04A return: 
04A STORE s1, ISR_restore_s1
04B STORE s2, ISR_restore_s2
04C STORE s3, ISR_restore_s3
04D FETCH s0, ISR_preserve_s0
04E FETCH s1, ISR_preserve_s1
04F FETCH s2, ISR_preserve_s2
050 FETCH s3, ISR_preserve_s3
051 RETURNI ENABLE
052 add_sample_carry: 
052 ADD s2, 01;carry from add_sample
053 JUMP inc_counter
054 LED_80: 
054 SL0 s2;check for 1000_0000
055 JUMP NC, LED_40
056 LOAD s1, FF;LED output 1111_1111
057 OUTPUT s1, LED_port
058 JUMP reset
059 LED_40: 
059 SL0 s2;check for 0100_0000
05A JUMP NC, LED_20
05B LOAD s1, FE;LED output 1111_1110
05C OUTPUT s1, LED_port
05D JUMP reset
05E LED_20: 
05E SL0 s2;check for 0010_0000
05F JUMP NC, LED_10
060 LOAD s1, FC;LED output 1111_1100
061 OUTPUT s1, LED_port
062 JUMP reset
063 LED_10: 
063 SL0 s2;check for 0001_0000
064 JUMP NC, LED_08
065 LOAD s1, F8;LED output 1111_1000
066 OUTPUT s1, LED_port
067 JUMP reset
068 LED_08: 
068 SL0 s2;check for 0000_1000
069 JUMP NC, LED_04
06A LOAD s1, F0;LED output 1111_0000
06B OUTPUT s1, LED_port
06C JUMP reset
06D LED_04: 
06D SL0 s2;check for 1000_0100
06E JUMP NC, LED_02
06F LOAD s1, E0;LED output 1110_0000
070 OUTPUT s1, LED_port
071 JUMP reset
072 LED_02: 
072 SL0 s2;check for 0000_0010
073 JUMP NC, LED_01
074 LOAD s1, C0;LED output 1100_0000
075 OUTPUT s1, LED_port
076 JUMP reset
077 LED_01: 
077 SL0 s2;check for 0000_0001
078 JUMP NC, LED_00
079 LOAD s1, 80;LED output 1000_0000
07A OUTPUT s1, LED_port
07B LED_00: 
07B LOAD s1, 00;LED output 1000_0000
07C OUTPUT s1, LED_port
07D reset: 
07D LOAD s1, 00
07E LOAD s2, 00
07F LOAD s3, 00
080 JUMP return
081 ;
081 ;
081 
;**************************************************************************************
081 ; Interrupt Vector
081 
;**************************************************************************************
081 ;
3FF ADDRESS 3FF
3FF JUMP ISR
3FF ;
3FF ;

PASS 5 - Writing reformatted PSM file
           pracpico.fmt

PASS 6 - Writing assembler log file
           pracpico.log

PASS 7 - Writing coefficient file
           pracpico.coe

PASS 8 - Writing VHDL memory definition file
           pracpico.vhd

PASS 9 - Writing Verilog memory definition file
           pracpico.v

PASS 10 - Writing System Generator memory definition file
           pracpico.m

PASS 11 - Writing memory definition files
           pracpico.hex
           pracpico.dec
           pracpico.mem


KCPSM3 successful.

KCPSM3 complete.

